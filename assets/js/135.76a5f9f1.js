(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{645:function(v,_,e){"use strict";e.r(_);var p=e(12),t=Object(p.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("位运算\nvue3.2中利用位运算，优化了速度。")]),v._v(" "),e("p",[v._v("位运算常常用于做权限管理。")]),v._v(" "),e("p",[v._v("举例padStart")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("在不用Vue的时候，dom和数据是分开的，如果数据发生变化后，则需要重新render()，即重新渲染页面；但是如果数据发生变化后，但是页面并没有用到该数据，重新渲染的话，会造成新能浪费。")]),v._v(" "),e("p",[v._v("这个时候就用到了proxy，对数据进行监听，当被页面依赖的数据发生变化的时候，才进行渲染。")]),v._v(" "),e("p",[v._v("再进一步，对项目进一步解耦，各个渲染函数分开。")]),v._v(" "),e("p",[v._v("Vue数据更新")]),v._v(" "),e("p",[v._v("数据初始化 =》 收集依赖关系\n数据变化之后 =》 proxy响应式会通知到组件  // 组件内部虚拟dom 计算diff 汇总更新")]),v._v(" "),e("p",[v._v("React 数据更新")]),v._v(" "),e("p",[v._v("数据变化后 setState =》 计算虚拟dom =》 计算出diff =》 更新")]),v._v(" "),e("p",[v._v("两者区别在于：vue中是组件中计算虚拟dom，而react没有组件概念，所以是全部计算虚拟dom，项目大的话可能会卡。")]),v._v(" "),e("p",[v._v("react可能会卡，是如何解决的呢？\n首先是事件切片，计算量虽然没有变化，但是利用在浏览器空闲的时间进行计算，感觉没那么卡了。")]),v._v(" "),e("p",[v._v("将fiber转成链表，可以中断执行，等空闲的时候再继续执行。")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("keepalive组件\n页面跳转时候，保存组件状态。")]),v._v(" "),e("p",[v._v("组件状态缓存过多组件时候，涉及到cache淘汰的时候，LRU淘汰缓存。")]),v._v(" "),e("p",[v._v("lc 126 LRU缓存：")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("编译原理")]),v._v(" "),e("p",[v._v("与生成虚拟dom相似")]),v._v(" "),e("p",[v._v("Github 项目:the-der-tiny-compiler")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("为什么vite中不可以用require？")]),v._v(" "),e("p",[v._v("因为在开发环境中，是通过type=module的方式引入的，可以直接用import。")]),v._v(" "),e("p",[v._v("vite首先是支持的是esmodule，然后是支持node_modules、非js结尾的文件，还有热更新。")]),v._v(" "),e("p",[v._v("为什么vite首次加载慢？import时候，是发起的网络请求，如果依赖文件过多会首次加载慢，vite优化的时候，会对依赖包进行预打包，这样只会发起一次网络请求。")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("ni")])])}),[],!1,null,null,null);_.default=t.exports}}]);